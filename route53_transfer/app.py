from __future__ import print_function
from collections import defaultdict

import csv, sys, time
from datetime import datetime
import itertools
from os import environ

from boto import route53
from boto import connect_s3
from boto.route53.record import Record, ResourceRecordSets
from boto.s3.key import Key

ts = time.strftime("%Y-%m-%dT%H:%M:%SZ", datetime.utcnow().utctimetuple())


class ChangeBatch():
    """
    Represents a single batch/transaction of changes to Route53

    Having such a class simplifies the handling of the change operations as
    we can use `ChangeBatch.add_change()` passing the change operation dict
    as it was returned by `compute_changes()`.
    """
    def __init__(self):
        self._changes = []

    @property
    def changes(self):
        return self._changes

    def add_change(self, change_operation):
        record = change_operation["record"]
        change = dict()
        change["operation"] = change_operation["operation"]
        change["change_dict"] = {**record.to_change_dict()}
        change["rr_values"] = []
        for value in record.resource_records:
            change["rr_values"].append(value)
        self._changes.append(change)


class ComparableRecord(object):
    def __init__(self, obj):
        for k, v in obj.__dict__.items():
            self.__dict__[k] = v

    def __eq__(self, other):
        return self.__dict__ == other.__dict__

    def __hash__(self):
        it = (self.name, self.type, self.alias_hosted_zone_id,
              self.alias_dns_name, tuple(sorted(self.resource_records)),
              self.ttl, self.region, self.weight, self.identifier,
              self.failover, self.alias_evaluate_target_health)
        return it.__hash__()

    def to_change_dict(self):
        data = {}
        for k, v in self.__dict__.items():
            if k == 'resource_records':
                continue
            else:
                data[k] = v
        return data

    def __repr__(self):
        rr = " ".join(self.resource_records)
        extra_info = f"{self.ttl}:{rr}"

        if self.alias_dns_name:
            extra_info = f"ALIAS {self.alias_hosted_zone_id} {self.alias_dns_name} " \
                         f"(EvalTarget {self.alias_evaluate_target_health})"

        return f"<ComparableRecord:{self.name}:{self.type}:{extra_info}>"


def exit_with_error(error):
    sys.stderr.write(error)
    sys.exit(1)


def get_aws_credentials(params):
    access_key = params.get('--access-key-id') or environ.get('AWS_ACCESS_KEY_ID')
    if params.get('--secret-key-file'):
        with open(params.get('--secret-key-file')) as f:
            secret_key = f.read().strip()
    else:
        secret_key = params.get('--secret-key') or environ.get('AWS_SECRET_ACCESS_KEY')
    return access_key, secret_key


def get_zone(con, zone_name, vpc):

    res = con.get_all_hosted_zones()
    zones = res['ListHostedZonesResponse']['HostedZones']
    zone_list = [z for z in zones
                    if z['Config']['PrivateZone'] == (u'true' if vpc.get('is_private') else u'false')
                        and z['Name'] == zone_name + '.']

    for zone in zone_list:
        data = {}
        data['id'] = zone.get('Id','').replace('/hostedzone/', '')
        data['name'] = zone.get('Name')
        if vpc.get("is_private"):
            z = con.get_hosted_zone(data.get('id'))
            z_vpc_id = z.get('GetHostedZoneResponse',{}).get('VPCs',{}).get('VPC',{}).get('VPCId','')
            if z_vpc_id == vpc.get('id'):
                return data
            else:
                continue
        else:
            return data
    else:
        return None


def create_zone(con, zone_name, vpc):
    con.create_hosted_zone(domain_name=zone_name,
                           private_zone=vpc.get('is_private'),
                           vpc_region=vpc.get('region'),
                           vpc_id=vpc.get('id'),
                           comment='autogenerated by route53-transfer @ {}'.format(ts))
    return get_zone(con, zone_name, vpc)


def inflate_csv_record(all_recs):
    """
    Converts a CSV zone record into a route53.record.Record instance

    Example:

        NAME,TYPE,VALUE,TTL,REGION,WEIGHT,SETID,FAILOVER,EVALUATE_HEALTH
        db.example.com.,A,1.2.3.4,300,,,production-db,,

    :param all_recs: All CSV records for a single resource
    :return: Record
    """
    record = Record()

    # List of CSV fields as parsed from a single line of a zone dump
    csv_fields = all_recs[0]

    record.name = csv_fields[0]
    record.type = csv_fields[1]

    if csv_fields[2].startswith('ALIAS'):
        _, alias_hosted_zone_id, alias_dns_name = csv_fields[2].split(':')
        record.alias_hosted_zone_id = alias_hosted_zone_id
        record.alias_dns_name = alias_dns_name
    else:
        record.resource_records = [r[2] for r in all_recs]
        record.ttl = csv_fields[3]

    record.region = csv_fields[4] or None
    record.weight = csv_fields[5] or None
    record.identifier = csv_fields[6] or None
    record.failover = csv_fields[7] or None

    try:
        if csv_fields[8] == 'True':
            record.alias_evaluate_target_health = True
        elif csv_fields[8] == 'False':
            record.alias_evaluate_target_health = False
        else:
            record.alias_evaluate_target_health = None
    except IndexError as e:
        print("Invalid record: ", csv_fields)
        raise e

    return record


def group_values(lines):
    records = []
    for _, records in itertools.groupby(lines, lambda row: row[0:2]):
        for __, by_value in itertools.groupby(records, lambda row: row[-3:]):
            recs = list(by_value)  # consume the iterator so we can grab positionally
            record = inflate_csv_record(recs)

            yield record


def read_lines(file_in):
    reader = csv.reader(file_in)
    lines = list(reader)
    if lines[0][0] == 'NAME':
        lines = lines[1:]
    return lines


def read_records(file_in):
    return list(group_values(read_lines(file_in)))


def skip_apex_soa_ns(zone, records):
    for record in records:
        if record.name == zone['name'] and record.type in ['SOA', 'NS']:
            continue
        else:
            yield record


def comparable(records):
    return {ComparableRecord(record) for record in records}


def get_file(filename, mode):
    ''' Get a file-like object for a filename and mode.

        If filename is "-" return one of stdin or stdout.
    '''
    if filename == '-':
        if mode.startswith('r'):
            return sys.stdin
        elif mode.startswith('w'):
            return sys.stdout
        else:
            raise ValueError('Unknown mode "{}"'.format(mode))
    else:
        return open(filename, mode)


def load(con, zone_name, file_in, **kwargs):
    ''' Send DNS records from input file to Route 53.

        Arguments are Route53 connection, zone name, vpc info, and file to open for reading.
    '''
    dry_run = kwargs.get('dry_run', False)
    use_upsert = kwargs.get('use_upsert', False)

    vpc = kwargs.get('vpc', {})

    zone = get_zone(con, zone_name, vpc)
    if not zone:
        if dry_run:
            print('CREATE ZONE:', zone_name)
        else:
            zone = create_zone(con, zone_name, vpc)

    existing_records = con.get_all_rrsets(zone['id'])
    desired_records = read_records(file_in)

    changes = compute_changes(zone, existing_records, desired_records,
                              use_upsert=use_upsert)

    if dry_run:
        print("Dry run requested: no changes are going to be applied")
        for change in changes:
            operation = change["operation"]
            record = change["record"]
            print(operation, record_short_summary(record))
    else:
        r53_update_batches = changes_to_r53_updates(con, zone, changes)
        if r53_update_batches:
            print("Applying changes...")
            for update_batch in r53_update_batches:
                update_batch.commit()
            print("Done.")
        else:
            print("No changes.")


def assign_change_priority(zone: dict, change_operations: list) -> None:
    """
    Given a list of change operations derived from the difference of two zones
    files, assign a priority integer to each change operation.

    The priority integer serves two purposes:

    1. Identify the relative order the changes. The target of an alias record
       will have a higher priority, since it needs to be present when we
       commit our change transaction.

    2. Group together all change operations that can be committed together
       in the same ResourceRecordSet change transaction.
    """
    rr_prio = defaultdict(int)

    def is_same_zone(change: dict) -> bool:
        return change["zone"]["id"] == zone["id"]

    def is_alias(change: ComparableRecord) -> bool:
        record = change["record"]
        return record.alias_dns_name is not None and is_same_zone(change)

    def is_new_alias(change: ComparableRecord) -> bool:
        return is_alias(change) and change["operation"] in ("CREATE", "UPSERT")

    for change in change_operations:
        if is_new_alias(change):
            record = change["record"]
            rr_prio[record.alias_dns_name] += 1

    for change in change_operations:
        if is_new_alias(change):
            record = change["record"]
            rr_prio[record.alias_dns_name] += rr_prio[record.name]

    for change in change_operations:
        record = change["record"]
        change["prio"] = rr_prio[record.name]


def changes_to_r53_updates(zone, change_operations):
    """
    Given a list of zone change operations as computed by `compute_changes()`,
    returns a list of R53 update batches. Normally one update batch, that is,
    a `ResourceRecordSets` object, will suffice for all updates. In certain
    cases, when records are aliases and their target records do not already
    exist in a zone, it's necessary to split the zone updates in different
    batches, which have to be committed in two separate operations.

    :param zone: Route53 zone object (dict with `id` and `name`)
    :param change_operations: list of zone change operations as returned by
           `compute_changes()`
    :return: r53_updates: list of ChangeBatch objects
    """

    assign_change_priority(zone, change_operations)

    r53_update_batches = []
    current_batch = ChangeBatch()
    current_prio = None

    for change in sorted(change_operations, key=lambda c: c["prio"], reverse=True):
        order = change["prio"]

        if current_prio is None:
            current_prio = order

        if order != current_prio:
            if current_batch.changes:
                r53_update_batches.append(current_batch)
            current_batch = ChangeBatch()

        current_batch.add_change(change)
        current_prio = order

    if current_batch.changes:
        r53_update_batches.append(current_batch)

    return r53_update_batches


def compute_changes(zone, existing_records, desired_records, use_upsert=False):
    """
    Given two sets of existing and desired resource records, compute the
    list of transactions (ResourceRecordSets changes) that will bring us
    from the existing state to the desired state.

    We need to take into account that we can't commit our changes in a single
    transaction in certain cases. One such cases is when we introduce records
    that are aliases to existing records. Route53 will reject our updates
    if the target record for the alias does not exist yet. The workaround is
    to execute the change in two distinct transactions (ResourceRecordSet
    changes), the first to commit the target resources of all the new aliases
    and the second one for all the other resource records.

    :param zone: Route53 zone object
    :param existing_records: list of rrsets that exist in the r53 zone
    :param desired_records: list of rrsets that we desire as final state
    :param use_upsert: if True, prefers UPSERT operations to CREATE and DELETE
    :return: list of ResourceRecordSet changes to be applied
    """

    existing_records = comparable(skip_apex_soa_ns(zone, existing_records))
    desired_records = comparable(skip_apex_soa_ns(zone, desired_records))

    to_delete = existing_records.difference(desired_records)
    to_add = desired_records.difference(existing_records)
    changes = list()

    def is_in_set(record: ComparableRecord, s: set) -> bool:
        for entry in s:
            if entry.to_change_dict()["name"] == record.to_change_dict()["name"]:
                return True
        return False

    def sort_by_name(s: set):
        return sorted(s, key=lambda comparable_record: comparable_record.name)

    if to_add or to_delete:
        for record in sort_by_name(to_add):
            op_type = "UPSERT" if use_upsert and is_in_set(record, to_delete) else "CREATE"
            changes.append({"zone": zone,
                            "operation": op_type,
                            "record": record})

        for record in sort_by_name(to_delete):
            if not (use_upsert and is_in_set(record, to_add)):
                changes.insert(0, {"zone": zone,
                                   "operation": "DELETE",
                                   "record": record})

    return changes


def dump(con, zone_name, fout, **kwargs):
    ''' Receive DNS records from Route 53 to output file.

        Arguments are Route53 connection, zone name, vpc info, and file to open for writing.
    '''
    vpc = kwargs.get('vpc', {})

    zone = get_zone(con, zone_name, vpc)
    if not zone:
        exit_with_error("ERROR: {} zone {} not found!".format('Private' if vpc.get('is_private') else 'Public',
                                                              zone_name))

    out = csv.writer(fout)
    out.writerow(['NAME', 'TYPE', 'VALUE', 'TTL', 'REGION', 'WEIGHT', 'SETID', 'FAILOVER', "EVALUATE_HEALTH"])

    records = list(con.get_all_rrsets(zone['id']))
    for r in records:
        lines = record_to_stringlist(r)
        for line in lines:
            out.writerow(line)

    fout.flush()


def record_to_stringlist(r: Record) -> list:
    out_lines = []

    if r.alias_dns_name:
        vals = [':'.join(['ALIAS', r.alias_hosted_zone_id, r.alias_dns_name])]
    else:
        vals = r.resource_records

    for val in vals:
        out_lines.append([
            r.name, r.type, val, r.ttl, r.region, r.weight, r.identifier,
            r.failover, r.alias_evaluate_target_health])

    return out_lines


def record_short_summary(r: Record) -> str:
    """
    Given a R53 resource record, returns a short string summary of it.

    Used when showing what records would be created, modified or deleted
    in a dry-run execution.

    :param r: R53 resource record
    :return: short summary string of the input record
    """
    if r.alias_dns_name:
        return f"{r.name} {r.type} ALIAS:{r.alias_hosted_zone_id}:{r.alias_dns_name} {r.ttl}"
    else:
        return f"{r.name} {r.type} {r.resource_records} {r.ttl}"


def up_to_s3(con, file, s3_bucket):
    con.create_bucket(s3_bucket)
    bucket = con.get_bucket(s3_bucket)
    bucket_key = Key(bucket)
    bucket_key.key = file
    bucket_key.set_contents_from_filename(file, num_cb=10)


def run(params):
    access_key, secret_key = get_aws_credentials(params)
    con = route53.connect_to_region('universal', aws_access_key_id=access_key, aws_secret_access_key=secret_key)
    con_s3 = connect_s3(aws_access_key_id=access_key, aws_secret_access_key=secret_key)
    zone_name = params['<zone>']
    filename = params['<file>']

    vpc = {}
    if params.get('--private'):
        vpc['is_private'] = True
        vpc['region'] = params.get('--vpc-region') or environ.get('AWS_DEFAULT_REGION')
        vpc['id'] = params.get('--vpc-id')
        if not vpc.get('region') or not vpc.get('id'):
            exit_with_error("ERROR: Private zones require associated VPC Region and ID "
                            "(--vpc-region, --vpc-id)".format(zone_name))
    else:
        vpc['is_private'] = False

    if params.get('dump'):
        dump(con, zone_name, get_file(filename, 'w'), vpc=vpc)
        if params.get('--s3-bucket'):
            up_to_s3(con_s3, params.get('<file>'), params.get('--s3-bucket'))

    elif params.get('load'):
        dry_run = params.get('--dry-run', False)
        use_upsert = params.get('--use-upsert', False)

        load(con, zone_name, get_file(filename, 'r'), vpc=vpc,
             dry_run=dry_run, use_upsert=use_upsert)
    else:
        return 1
